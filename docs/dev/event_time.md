# Event Time

## Event Time / Processing Time / Ingestion Time
Flink在流媒体程序中支持不同的时间概念。

处理时间:处理时间是指执行相应操作的机器的系统时间。

当流程序在处理时间上运行时，所有基于时间的操作(比如时间窗口)都将使用运行各自操作符的机器的系统时钟。每小时处理时间窗口将包括在系统时钟显示完整小时之间到达特定操作员的所有记录。例如，如果应用程序在上午9:15开始运行，第一个小时处理时间窗口将包括上午9:15到上午10:00之间处理的事件，下一个窗口将包括上午10:00到11:00之间处理的事件，依此类推。

处理时间是时间的最简单概念，不需要流和机器之间的协调。它提供了最好的性能和最低的延迟。然而,在分布式和异步环境处理时间不提供决定论,因为它是容易的速度记录到系统中(例如从消息队列),运营商之间流动的速度记录在系统内部,并中断(预定,或以其他方式)。

事件时间:事件时间是每个事件在其生产设备上发生的时间。这个时间通常在记录进入Flink之前嵌入到记录中，并且可以从每个记录中提取事件时间戳。在事件时间中，时间的进程取决于数据，而不是任何挂钟。事件时间程序必须指定如何生成事件时间水印，这是表示事件时间进展的机制。这种水印机制将在下面的一节中描述。

在一个完美的世界中，事件时间处理将产生完全一致和确定的结果，而不管事件何时到达或它们的顺序如何。然而，除非已知事件是按顺序到达的(通过时间戳)，否则在等待无序事件时，事件时间处理会导致一些延迟。由于只能等待有限的一段时间，这就限制了事件时间应用程序的确定性。

假设所有数据都已到达，事件时间操作将按预期运行，即使在处理无序或延迟的事件或重新处理历史数据时，也会产生正确和一致的结果。例如，每小时事件时间窗口将包含所有记录，这些记录携带属于该小时的事件时间戳，无论它们以何种顺序到达，或在什么时候处理。(有关更多信息，请参阅有关延迟事件的部分。)

注意，有时当事件时间程序实时处理实时数据时，它们会使用一些处理时间操作，以确保它们以及时的方式进行。

摄入时间:摄入时间是事件进入Flink的时间。在源操作符中，每条记录都以时间戳的形式获取源的当前时间，基于时间的操作(如时间窗口)引用该时间戳。

摄入时间概念上位于事件时间和处理时间之间。与处理时间相比，它稍微昂贵一些，但是提供了更可预测的结果。由于摄取时间使用稳定的时间戳(在源上分配一次)，记录上的不同窗口操作将引用相同的时间戳，而在处理时间中，每个窗口操作人员可以将记录分配到不同的窗口(基于本地系统时钟和任何传输延迟)。

与事件时间相比，摄入时间程序不能处理任何无序的事件或延迟的数据，但程序不必指定如何生成水印。

在内部，摄取时间处理得很像事件时间，但是使用自动时间戳分配和自动水印生成。

![times_clocks](../images/times_clocks.svg)

## Setting a Time Characteristic
Flink DataStream程序的第一部分通常设置基本时间特性。该设置定义了数据源的行为方式(例如，它们是否会分配时间戳)，以及KeyedStream.timeWindow(time .seconds(30))等窗口操作应该使用什么时间概念。

下面的示例显示了一个Flink程序，它以小时为单位聚合事件。窗口的行为与时间特性相适应。

```java
final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);

// alternatively:
// env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);
// env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

DataStream<MyEvent> stream = env.addSource(new FlinkKafkaConsumer09<MyEvent>(topic, schema, props));

stream
    .keyBy( (event) -> event.getUser() )
    .timeWindow(Time.hours(1))
    .reduce( (a, b) -> a.add(b) )
    .addSink(...);
```

注意，为了在事件时间中运行这个例子，程序需要使用直接定义数据事件时间并自己发出水印的源，或者程序必须在源之后注入一个时间戳分配者&水印生成器。这些函数描述了如何访问事件时间戳，以及事件流显示的外部细度。

下一节描述时间戳和水印背后的一般机制。有关如何在Flink DataStream API中使用时间戳分配和水印生成的指南，请参阅生成时间戳/水印。

## Event Time and Watermarks

注意:Flink实现了来自数据流模型的许多技术。有关事件时间和水印的详细介绍，请参阅下面的文章。

流101作者泰勒·阿基多
数据流模型纸
支持事件时间的流处理器需要一种方法来度量事件时间的进度。例如，当事件时间超过一个小时时，需要通知每小时构建一个窗口的窗口操作符，以便操作符可以关闭正在运行的窗口。

事件时间可以独立于处理时间(由挂钟测量)进行。例如，在一个程序中，操作员当前的事件时间可能稍微落后于处理时间(考虑到接收事件的延迟)，而两者的处理速度相同。另一方面，另一个流媒体程序可能只需要几秒钟的处理，就可以通过快速转发已经缓存在Kafka主题(或另一个消息队列)中的一些历史数据，在几周的事件时间内进行处理。

在Flink中，衡量事件时间进展的机制是水印。水印流作为数据流的一部分,一个时间戳t。一个水印(t)宣称事件时间已达到时间t的流,这意味着不应该有更多的元素从流时间戳t ' < = t(即事件与时间戳或等于水印)。

下图显示了带有(逻辑)时间戳和内联水印的事件流。在这个例子中，事件是按顺序排列的(关于它们的时间戳)，这意味着水印只是流中的周期标记。

![stream_watermark_in_order](../images/stream_watermark_in_order.svg)

水印对于无序流非常重要，如下图所示，在无序流中，事件不是按照它们的时间戳排序的。一般来说，水印是一种声明，到流中的那个点时，直到某个时间戳为止的所有事件都应该已经到达。水印到达操作符后，操作符可以将其内部事件时钟提前到水印的值。

![stream_watermark_out_of_order](../images/stream_watermark_out_of_order.svg)

注意，事件时间由新创建的流元素(或元素)继承，这些流元素或来自生成它们的事件，或来自触发这些元素创建的水印。

## Watermarks in Parallel Streams
水印在源函数处生成，或者直接在源函数之后生成。源函数的每个并行子任务通常独立地生成其水印。这些水印定义了该特定并行源的事件时间。

当水印流经流媒体程序时，它们会将事件时间提前到它们到达的操作符处。每当操作符提前它的事件时间时，它就为后续操作符在下游生成一个新的水印。

一些操作符使用多个输入流;例如，在keyBy(…)或partition(…)函数之后的union或运算符。此类操作符的当前事件时间是其输入流的事件时间的最小值。当它的输入流更新它们的事件时间时，操作符也更新它们。

下图显示了一个通过并行流流动的事件和水印，以及操作符跟踪事件时间的示例。

![parallel_streams_watermarks](../images/parallel_streams_watermarks.svg)

注意Kafka源代码支持每个分区的水印，您可以在这里阅读更多信息。

## Late Elements

某些元素可能会违反水印条件，这意味着即使水印(t)已经发生，也会出现更多具有时间戳t ' <= t的元素。事实上，在许多实际的设置中，某些元素可能被任意延迟，因此不可能指定某个事件时间戳的所有元素发生的时间。此外，即使延迟是有限制的，将水印延迟太多通常也是不可取的，因为这会导致事件时间窗的计算延迟太多。

由于这个原因，流媒体程序可能会显式地期望一些较晚的元素。延迟元素是在系统的事件时间时钟(由水印表示)已经通过了延迟元素的时间戳之后到达的元素。有关如何在事件时间窗口中处理延迟元素的更多信息，请参见“允许延迟”。

## Idling sources

目前，使用纯事件时间水印生成器，如果没有要处理的元素，水印将无法进行处理。这意味着，在传入数据出现间隙的情况下，事件时间将不会进展，例如窗口操作符将不会被触发，因此现有窗口将无法生成任何输出数据。

为了避免这种情况，可以使用周期水印赋值器，它不仅基于元素时间戳进行赋值。一个示例解决方案可以是一个转让者，该转让者在一段时间没有观察到新事件之后，转而使用当前处理时间作为时间基础。

可以使用SourceFunction.SourceContext#markAsTemporarilyIdle将源标记为空闲。有关详细信息，请参阅此方法的Javadoc和StreamStatus。

## Debugging Watermarks
有关运行时调试水印，请参阅调试窗口和事件时间部分。

## How operators are processing watermarks

一般来说，操作人员需要在将给定水印转发到下游之前对其进行完整的处理。例如，WindowOperator将首先评估应该触发哪个窗口，并且只有在生成由水印触发的所有输出之后，水印本身才会被发送到下游。换句话说，由于水印的出现而产生的所有元素都会在水印之前发出。

同样的规则也适用于TwoInputStreamOperator。然而，在这种情况下，操作符的当前水印被定义为其两个输入的最小值。

此行为的细节由OneInputStreamOperator# process水印、两个oinputstreamoperator #processWatermark1和两个oinputstreamoperator #processWatermark2方法的实现定义。